// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: purchases.sql

package generated

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

const deletePurchase = `-- name: DeletePurchase :exec
DELETE
FROM purchases
WHERE purchase_id = $1
  AND organization_id = $2
`

type DeletePurchaseParams struct {
	PurchaseID     uuid.UUID `json:"purchase_id"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) DeletePurchase(ctx context.Context, arg DeletePurchaseParams) error {
	_, err := q.db.ExecContext(ctx, deletePurchase, arg.PurchaseID, arg.OrganizationID)
	return err
}

const getGroupedPurchasesNext = `-- name: GetGroupedPurchasesNext :many
SELECT pg.purchase_group_id,
       pg.supplier,
       pg.total_cost,
       pg.purchase_date,
       pg.payment_method,
       pg.branch_uuid,
       pg.user_email,
       pg.comments,
       pg.partner_id,
       pg.organization_id,
       json_agg(json_build_object(
               'purchase_id', p.purchase_id,
               'product_id', p.product_id,
               'product_name', p.product_name,
               'unit_purchase_price', p.unit_purchase_price,
               'units', p.units,
               'branch_uuid', p.branch_uuid,
               'organization_id', p.organization_id
                )) AS purchase_items
FROM purchase_group pg
         LEFT JOIN purchases p ON pg.purchase_group_id = p.purchase_group_id
         LEFT JOIN partners pt ON pg.partner_id = pt.partner_id
WHERE pg.purchase_group_id < $1
  AND pg.branch_uuid = $2
  AND pg.organization_id = $3
  AND pt.partner_name like $4
  AND (cast($5 as date) IS NULL OR pg.purchase_date >= $5)
  AND (cast($6 as date) IS NULL OR pg.purchase_date <= $6)

GROUP BY pg.purchase_group_id
ORDER BY pg.purchase_group_id DESC
    LIMIT $7
`

type GetGroupedPurchasesNextParams struct {
	PurchaseGroupID uuid.UUID `json:"purchase_group_id"`
	BranchUuid      uuid.UUID `json:"branch_uuid"`
	OrganizationID  uuid.UUID `json:"organization_id"`
	PartnerName     string    `json:"partner_name"`
	Column5         time.Time `json:"column_5"`
	Column6         time.Time `json:"column_6"`
	Limit           int32     `json:"limit"`
}

type GetGroupedPurchasesNextRow struct {
	PurchaseGroupID uuid.UUID       `json:"purchase_group_id"`
	Supplier        sql.NullString  `json:"supplier"`
	TotalCost       decimal.Decimal `json:"total_cost"`
	PurchaseDate    time.Time       `json:"purchase_date"`
	PaymentMethod   sql.NullString  `json:"payment_method"`
	BranchUuid      uuid.UUID       `json:"branch_uuid"`
	UserEmail       string          `json:"user_email"`
	Comments        sql.NullString  `json:"comments"`
	PartnerID       uuid.NullUUID   `json:"partner_id"`
	OrganizationID  uuid.UUID       `json:"organization_id"`
	PurchaseItems   json.RawMessage `json:"purchase_items"`
}

// pt.partner_name,
func (q *Queries) GetGroupedPurchasesNext(ctx context.Context, arg GetGroupedPurchasesNextParams) ([]GetGroupedPurchasesNextRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupedPurchasesNext,
		arg.PurchaseGroupID,
		arg.BranchUuid,
		arg.OrganizationID,
		arg.PartnerName,
		arg.Column5,
		arg.Column6,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupedPurchasesNextRow
	for rows.Next() {
		var i GetGroupedPurchasesNextRow
		if err := rows.Scan(
			&i.PurchaseGroupID,
			&i.Supplier,
			&i.TotalCost,
			&i.PurchaseDate,
			&i.PaymentMethod,
			&i.BranchUuid,
			&i.UserEmail,
			&i.Comments,
			&i.PartnerID,
			&i.OrganizationID,
			&i.PurchaseItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchase = `-- name: GetPurchase :one
SELECT purchase_id, purchase_group_id, product_id, product_name, unit_purchase_price, units, branch_uuid, organization_id
FROM purchases
WHERE purchases.purchase_id = $1
  AND branch_uuid = $2
  AND organization_id = $3
`

type GetPurchaseParams struct {
	PurchaseID     uuid.UUID `json:"purchase_id"`
	BranchUuid     uuid.UUID `json:"branch_uuid"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) GetPurchase(ctx context.Context, arg GetPurchaseParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, getPurchase, arg.PurchaseID, arg.BranchUuid, arg.OrganizationID)
	var i Purchase
	err := row.Scan(
		&i.PurchaseID,
		&i.PurchaseGroupID,
		&i.ProductID,
		&i.ProductName,
		&i.UnitPurchasePrice,
		&i.Units,
		&i.BranchUuid,
		&i.OrganizationID,
	)
	return i, err
}

const insertOrUpdateProductsWithPurchasesAndPurchaseGroup = `-- name: InsertOrUpdateProductsWithPurchasesAndPurchaseGroup :many
WITH new_group AS (
INSERT INTO purchase_group (
    supplier,
    total_cost,
    payment_method,
    branch_uuid,
    user_email,
    comments,
    partner_id,
    organization_id
) VALUES ($1, -- supplier
    $2, -- total_cost
    $3, -- payment_method
    $4, -- branch_uuid
    $5, -- user_email
    $6, -- comments
    $7, -- partner_id
    $8 -- organization_id
    )
    RETURNING purchase_group_id),
    input_data AS (SELECT unnest($9::text[])     AS product_name,
    unnest($10::text[])    AS unique_name,
    unnest($11::numeric[]) AS unit_purchase_price,
    unnest($12::numeric[]) AS units,
    unnest($13::numeric[]) AS selling_price,
    unnest($14::text[])    AS measurement_unit),
    upserted_products AS (
INSERT INTO products (
    product_name,
    unique_name,
    selling_price,
    remaining_quantity,
    branch_uuid,
    measurement_unit,
    organization_id
)
SELECT i.product_name,
    i.unique_name,
    i.selling_price,
    i.units, -- initial quantity
    $4,      -- branch_uuid
    i.measurement_unit,
    $8       -- organization_id
FROM input_data i
ON CONFLICT (unique_name) DO UPDATE
    SET remaining_quantity = products.remaining_quantity + EXCLUDED.remaining_quantity,
    selling_price = EXCLUDED.selling_price
    RETURNING product_id, unique_name, product_name)
INSERT
INTO purchases (purchase_group_id,
                product_id,
                product_name,
                unit_purchase_price,
                units,
                branch_uuid,
                organization_id)
SELECT (SELECT purchase_group_id FROM new_group),
       p.product_id,
       p.product_name,
       i.unit_purchase_price,
       i.units,
       $4, -- branch_uuid
       $8  -- organization_id
FROM input_data i
         JOIN upserted_products p ON p.unique_name = i.unique_name
    RETURNING purchase_id, purchase_group_id, product_id, product_name, unit_purchase_price, units, branch_uuid, organization_id
`

type InsertOrUpdateProductsWithPurchasesAndPurchaseGroupParams struct {
	Supplier       sql.NullString    `json:"supplier"`
	TotalCost      decimal.Decimal   `json:"total_cost"`
	PaymentMethod  sql.NullString    `json:"payment_method"`
	BranchUuid     uuid.UUID         `json:"branch_uuid"`
	UserEmail      string            `json:"user_email"`
	Comments       sql.NullString    `json:"comments"`
	PartnerID      uuid.NullUUID     `json:"partner_id"`
	OrganizationID uuid.UUID         `json:"organization_id"`
	Column9        []string          `json:"column_9"`
	Column10       []string          `json:"column_10"`
	Column11       []decimal.Decimal `json:"column_11"`
	Column12       []decimal.Decimal `json:"column_12"`
	Column13       []decimal.Decimal `json:"column_13"`
	Column14       []string          `json:"column_14"`
}

func (q *Queries) InsertOrUpdateProductsWithPurchasesAndPurchaseGroup(ctx context.Context, arg InsertOrUpdateProductsWithPurchasesAndPurchaseGroupParams) ([]Purchase, error) {
	rows, err := q.db.QueryContext(ctx, insertOrUpdateProductsWithPurchasesAndPurchaseGroup,
		arg.Supplier,
		arg.TotalCost,
		arg.PaymentMethod,
		arg.BranchUuid,
		arg.UserEmail,
		arg.Comments,
		arg.PartnerID,
		arg.OrganizationID,
		pq.Array(arg.Column9),
		pq.Array(arg.Column10),
		pq.Array(arg.Column11),
		pq.Array(arg.Column12),
		pq.Array(arg.Column13),
		pq.Array(arg.Column14),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.PurchaseID,
			&i.PurchaseGroupID,
			&i.ProductID,
			&i.ProductName,
			&i.UnitPurchasePrice,
			&i.Units,
			&i.BranchUuid,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
