// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: branches.sql

package generated

import (
	"context"

	"github.com/google/uuid"
)

const getBranchToProductMapping = `-- name: GetBranchToProductMapping :many
SELECT DISTINCT p.product_name, b.branch_name
FROM products p
         INNER JOIN branches b ON p.branch_uuid = b.id
WHERE b.organization_id = $1
GROUP BY b.branch_name, p.product_name
`

type GetBranchToProductMappingRow struct {
	ProductName string `json:"product_name"`
	BranchName  string `json:"branch_name"`
}

func (q *Queries) GetBranchToProductMapping(ctx context.Context, organizationID uuid.UUID) ([]GetBranchToProductMappingRow, error) {
	rows, err := q.db.QueryContext(ctx, getBranchToProductMapping, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBranchToProductMappingRow
	for rows.Next() {
		var i GetBranchToProductMappingRow
		if err := rows.Scan(&i.ProductName, &i.BranchName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBranchToProductMappingFiltered = `-- name: GetBranchToProductMappingFiltered :many
SELECT DISTINCT p.product_name, b.branch_name
FROM products p
         INNER JOIN branches b ON p.branch_uuid = b.id
         INNER JOIN auth a ON (a.branch_uuids @> '{p.branch_uuid}') -- Check if branches UUID is in users's branches list (text array)
WHERE a.user_email = $1
  AND b.organization_id = $2
GROUP BY p.product_name, b.branch_name
`

type GetBranchToProductMappingFilteredParams struct {
	UserEmail      string    `json:"user_email"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

type GetBranchToProductMappingFilteredRow struct {
	ProductName string `json:"product_name"`
	BranchName  string `json:"branch_name"`
}

func (q *Queries) GetBranchToProductMappingFiltered(ctx context.Context, arg GetBranchToProductMappingFilteredParams) ([]GetBranchToProductMappingFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, getBranchToProductMappingFiltered, arg.UserEmail, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBranchToProductMappingFilteredRow
	for rows.Next() {
		var i GetBranchToProductMappingFilteredRow
		if err := rows.Scan(&i.ProductName, &i.BranchName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationBranches = `-- name: GetOrganizationBranches :many
SELECT id, branch_name
FROM branches
WHERE organization_id = $1
`

type GetOrganizationBranchesRow struct {
	ID         uuid.UUID `json:"id"`
	BranchName string    `json:"branch_name"`
}

func (q *Queries) GetOrganizationBranches(ctx context.Context, organizationID uuid.UUID) ([]GetOrganizationBranchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationBranches, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizationBranchesRow
	for rows.Next() {
		var i GetOrganizationBranchesRow
		if err := rows.Scan(&i.ID, &i.BranchName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBranchesUnNested = `-- name: GetUserBranchesUnNested :many
SELECT unnest(branch_uuids)
FROM auth
WHERE user_email = $1
`

func (q *Queries) GetUserBranchesUnNested(ctx context.Context, userEmail string) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getUserBranchesUnNested, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var unnest interface{}
		if err := rows.Scan(&unnest); err != nil {
			return nil, err
		}
		items = append(items, unnest)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBranch = `-- name: InsertBranch :one
INSERT INTO branches (unique_name, branch_name, organization_id)
VALUES ($1, $2, $3)
    RETURNING id, unique_name, branch_name, organization_id
`

type InsertBranchParams struct {
	UniqueName     string    `json:"unique_name"`
	BranchName     string    `json:"branch_name"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) InsertBranch(ctx context.Context, arg InsertBranchParams) (Branch, error) {
	row := q.db.QueryRowContext(ctx, insertBranch, arg.UniqueName, arg.BranchName, arg.OrganizationID)
	var i Branch
	err := row.Scan(
		&i.ID,
		&i.UniqueName,
		&i.BranchName,
		&i.OrganizationID,
	)
	return i, err
}
