// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: organization.sql

package generated

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countOrganizations = `-- name: CountOrganizations :one
SELECT COUNT(*) FROM organization
`

func (q *Queries) CountOrganizations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganizationWithID = `-- name: CreateOrganizationWithID :one

INSERT INTO organization (name)
VALUES ($1)
RETURNING id, name
`

// Organization CRUD Operations
func (q *Queries) CreateOrganizationWithID(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganizationWithID, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organization
WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, id)
	return err
}

const deleteOrganizationCascade = `-- name: DeleteOrganizationCascade :one
DELETE FROM organization
WHERE id = $1
RETURNING id, name
`

func (q *Queries) DeleteOrganizationCascade(ctx context.Context, id uuid.UUID) (Organization, error) {
	row := q.db.QueryRowContext(ctx, deleteOrganizationCascade, id)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, name
FROM organization
WHERE id = $1
`

func (q *Queries) GetOrganizationByID(ctx context.Context, id uuid.UUID) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getOrganizationByName = `-- name: GetOrganizationByName :one
SELECT id, name
FROM organization
WHERE name = $1
`

func (q *Queries) GetOrganizationByName(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByName, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getOrganizationStats = `-- name: GetOrganizationStats :one
SELECT 
    COUNT(*) as total_organizations,
    COUNT(CASE WHEN EXISTS(SELECT 1 FROM branches WHERE organization_id = organization.id) THEN 1 END) as organizations_with_branches,
    COUNT(CASE WHEN EXISTS(SELECT 1 FROM products WHERE organization_id = organization.id) THEN 1 END) as organizations_with_products
FROM organization
`

type GetOrganizationStatsRow struct {
	TotalOrganizations        int64 `json:"total_organizations"`
	OrganizationsWithBranches int64 `json:"organizations_with_branches"`
	OrganizationsWithProducts int64 `json:"organizations_with_products"`
}

func (q *Queries) GetOrganizationStats(ctx context.Context) (GetOrganizationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationStats)
	var i GetOrganizationStatsRow
	err := row.Scan(&i.TotalOrganizations, &i.OrganizationsWithBranches, &i.OrganizationsWithProducts)
	return i, err
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name
FROM organization
ORDER BY name
`

func (q *Queries) ListOrganizations(ctx context.Context) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationsWithCursorPagination = `-- name: ListOrganizationsWithCursorPagination :many
SELECT id, name
FROM organization
WHERE ($1::uuid IS NULL OR id > $1)
ORDER BY id
LIMIT $2
`

type ListOrganizationsWithCursorPaginationParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Limit   int32     `json:"limit"`
}

func (q *Queries) ListOrganizationsWithCursorPagination(ctx context.Context, arg ListOrganizationsWithCursorPaginationParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationsWithCursorPagination, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationsWithNameCursor = `-- name: ListOrganizationsWithNameCursor :many
SELECT id, name
FROM organization
WHERE ($1::text IS NULL OR name > $1)
ORDER BY name, id
LIMIT $2
`

type ListOrganizationsWithNameCursorParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) ListOrganizationsWithNameCursor(ctx context.Context, arg ListOrganizationsWithNameCursorParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationsWithNameCursor, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationsWithRelatedCounts = `-- name: ListOrganizationsWithRelatedCounts :many
SELECT 
    o.id,
    o.name,
    COUNT(DISTINCT b.id) as branch_count,
    COUNT(DISTINCT p.product_id) as product_count,
    COUNT(DISTINCT u.id) as user_count
FROM organization o
LEFT JOIN branches b ON o.id = b.organization_id
LEFT JOIN products p ON o.id = p.organization_id
LEFT JOIN user_organization_branches uob ON o.id = uob.organization_id
LEFT JOIN user_profile u ON uob.user_profile_id = u.id
WHERE ($1::uuid IS NULL OR o.id > $1)
GROUP BY o.id, o.name
ORDER BY o.id
LIMIT $2
`

type ListOrganizationsWithRelatedCountsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Limit   int32     `json:"limit"`
}

type ListOrganizationsWithRelatedCountsRow struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	BranchCount  int64     `json:"branch_count"`
	ProductCount int64     `json:"product_count"`
	UserCount    int64     `json:"user_count"`
}

func (q *Queries) ListOrganizationsWithRelatedCounts(ctx context.Context, arg ListOrganizationsWithRelatedCountsParams) ([]ListOrganizationsWithRelatedCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationsWithRelatedCounts, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationsWithRelatedCountsRow
	for rows.Next() {
		var i ListOrganizationsWithRelatedCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BranchCount,
			&i.ProductCount,
			&i.UserCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const organizationExists = `-- name: OrganizationExists :one
SELECT EXISTS(
    SELECT 1 FROM organization WHERE id = $1
)
`

func (q *Queries) OrganizationExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, organizationExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const organizationNameExists = `-- name: OrganizationNameExists :one
SELECT EXISTS(
    SELECT 1 FROM organization WHERE name = $1
)
`

func (q *Queries) OrganizationNameExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, organizationNameExists, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const searchOrganizationsByName = `-- name: SearchOrganizationsByName :many
SELECT id, name
FROM organization
WHERE name ILIKE '%' || $1 || '%'
ORDER BY name
LIMIT $2
`

type SearchOrganizationsByNameParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
}

func (q *Queries) SearchOrganizationsByName(ctx context.Context, arg SearchOrganizationsByNameParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, searchOrganizationsByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE organization
SET name = $2
WHERE id = $1
RETURNING id, name
`

type UpdateOrganizationParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, updateOrganization, arg.ID, arg.Name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
