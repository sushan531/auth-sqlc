// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package generated

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const checkProductExists = `-- name: CheckProductExists :one
SELECT COUNT(*)
FROM products
WHERE organization_id = $1
  AND unique_name = $2
`

type CheckProductExistsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	UniqueName     string    `json:"unique_name"`
}

func (q *Queries) CheckProductExists(ctx context.Context, arg CheckProductExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkProductExists, arg.OrganizationID, arg.UniqueName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const conditionalUpdateProduct = `-- name: ConditionalUpdateProduct :one
UPDATE products
SET product_name       = CASE
                             WHEN $1::INT = 1 THEN $2
                             ELSE product_name
END,
    product_image      = CASE
                             WHEN $3::INT = 1 THEN $4
                             ELSE product_image
END,
    description        = CASE
                             WHEN $5::INT = 1 THEN $6
                             ELSE description
END,
    selling_price      = CASE
                             WHEN $7::INT = 1 THEN $8
                             ELSE selling_price
END,
    remaining_quantity = CASE
                             WHEN $9::INT = 1 THEN $10
                             ELSE remaining_quantity
END,
    measurement_unit   = CASE
                             WHEN $11::INT = 1 THEN $12
                             ELSE measurement_unit
END,
    unique_name        = CASE
                             WHEN $13::INT = 1 THEN $14
                             ELSE unique_name
END
WHERE product_id = $15
  AND branch_uuid = $16
  AND organization_id = $17
RETURNING product_id, product_name, unique_name, product_image, description, selling_price, remaining_quantity, branch_uuid, measurement_unit, organization_id
`

type ConditionalUpdateProductParams struct {
	Column1           int32           `json:"column_1"`
	ProductName       string          `json:"product_name"`
	Column3           int32           `json:"column_3"`
	ProductImage      sql.NullString  `json:"product_image"`
	Column5           int32           `json:"column_5"`
	Description       sql.NullString  `json:"description"`
	Column7           int32           `json:"column_7"`
	SellingPrice      decimal.Decimal `json:"selling_price"`
	Column9           int32           `json:"column_9"`
	RemainingQuantity decimal.Decimal `json:"remaining_quantity"`
	Column11          int32           `json:"column_11"`
	MeasurementUnit   string          `json:"measurement_unit"`
	Column13          int32           `json:"column_13"`
	UniqueName        string          `json:"unique_name"`
	ProductID         uuid.UUID       `json:"product_id"`
	BranchUuid        uuid.UUID       `json:"branch_uuid"`
	OrganizationID    uuid.UUID       `json:"organization_id"`
}

func (q *Queries) ConditionalUpdateProduct(ctx context.Context, arg ConditionalUpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, conditionalUpdateProduct,
		arg.Column1,
		arg.ProductName,
		arg.Column3,
		arg.ProductImage,
		arg.Column5,
		arg.Description,
		arg.Column7,
		arg.SellingPrice,
		arg.Column9,
		arg.RemainingQuantity,
		arg.Column11,
		arg.MeasurementUnit,
		arg.Column13,
		arg.UniqueName,
		arg.ProductID,
		arg.BranchUuid,
		arg.OrganizationID,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.UniqueName,
		&i.ProductImage,
		&i.Description,
		&i.SellingPrice,
		&i.RemainingQuantity,
		&i.BranchUuid,
		&i.MeasurementUnit,
		&i.OrganizationID,
	)
	return i, err
}

const findProduct = `-- name: FindProduct :one
SELECT COUNT(*)
FROM products
WHERE products.product_name = $1
  AND branch_uuid = $2
  AND organization_id = $3
`

type FindProductParams struct {
	ProductName    string    `json:"product_name"`
	BranchUuid     uuid.UUID `json:"branch_uuid"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) FindProduct(ctx context.Context, arg FindProductParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findProduct, arg.ProductName, arg.BranchUuid, arg.OrganizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllProductsNext = `-- name: GetAllProductsNext :many
SELECT product_id, product_name, unique_name, product_image, description, selling_price, remaining_quantity, branch_uuid, measurement_unit, organization_id
FROM products
WHERE (product_name LIKE $1 OR $1 IS NULL)
  AND branch_uuid = $2
  AND product_id > $3
  AND organization_id = $4
ORDER BY product_id ASC
    LIMIT $5
`

type GetAllProductsNextParams struct {
	ProductName    string    `json:"product_name"`
	BranchUuid     uuid.UUID `json:"branch_uuid"`
	ProductID      uuid.UUID `json:"product_id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) GetAllProductsNext(ctx context.Context, arg GetAllProductsNextParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductsNext,
		arg.ProductName,
		arg.BranchUuid,
		arg.ProductID,
		arg.OrganizationID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.UniqueName,
			&i.ProductImage,
			&i.Description,
			&i.SellingPrice,
			&i.RemainingQuantity,
			&i.BranchUuid,
			&i.MeasurementUnit,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductsPrev = `-- name: GetAllProductsPrev :many
SELECT product_id, product_name, unique_name, product_image, description, selling_price, remaining_quantity, branch_uuid, measurement_unit, organization_id
FROM products
WHERE (product_name LIKE $1 OR $1 IS NULL)
  AND branch_uuid = $2
  AND product_id >= $3
  AND product_id <= $4
  AND organization_id = $5
ORDER BY product_id ASC
    LIMIT $6
`

type GetAllProductsPrevParams struct {
	ProductName    string    `json:"product_name"`
	BranchUuid     uuid.UUID `json:"branch_uuid"`
	ProductID      uuid.UUID `json:"product_id"`
	ProductID_2    uuid.UUID `json:"product_id_2"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) GetAllProductsPrev(ctx context.Context, arg GetAllProductsPrevParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductsPrev,
		arg.ProductName,
		arg.BranchUuid,
		arg.ProductID,
		arg.ProductID_2,
		arg.OrganizationID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.UniqueName,
			&i.ProductImage,
			&i.Description,
			&i.SellingPrice,
			&i.RemainingQuantity,
			&i.BranchUuid,
			&i.MeasurementUnit,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT product_id, product_name, unique_name, product_image, description, selling_price, remaining_quantity, branch_uuid, measurement_unit, organization_id
FROM products
WHERE products.product_id = $1
  AND branch_uuid = $2
  AND organization_id = $3
`

type GetProductParams struct {
	ProductID      uuid.UUID `json:"product_id"`
	BranchUuid     uuid.UUID `json:"branch_uuid"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) GetProduct(ctx context.Context, arg GetProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, arg.ProductID, arg.BranchUuid, arg.OrganizationID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.UniqueName,
		&i.ProductImage,
		&i.Description,
		&i.SellingPrice,
		&i.RemainingQuantity,
		&i.BranchUuid,
		&i.MeasurementUnit,
		&i.OrganizationID,
	)
	return i, err
}

const insertProduct = `-- name: InsertProduct :one
INSERT INTO products (branch_uuid, unique_name, product_name, product_image, description, selling_price,
                      remaining_quantity,
                      measurement_unit, organization_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    RETURNING product_id, product_name, unique_name, product_image, description, selling_price, remaining_quantity, branch_uuid, measurement_unit, organization_id
`

type InsertProductParams struct {
	BranchUuid        uuid.UUID       `json:"branch_uuid"`
	UniqueName        string          `json:"unique_name"`
	ProductName       string          `json:"product_name"`
	ProductImage      sql.NullString  `json:"product_image"`
	Description       sql.NullString  `json:"description"`
	SellingPrice      decimal.Decimal `json:"selling_price"`
	RemainingQuantity decimal.Decimal `json:"remaining_quantity"`
	MeasurementUnit   string          `json:"measurement_unit"`
	OrganizationID    uuid.UUID       `json:"organization_id"`
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, insertProduct,
		arg.BranchUuid,
		arg.UniqueName,
		arg.ProductName,
		arg.ProductImage,
		arg.Description,
		arg.SellingPrice,
		arg.RemainingQuantity,
		arg.MeasurementUnit,
		arg.OrganizationID,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.UniqueName,
		&i.ProductImage,
		&i.Description,
		&i.SellingPrice,
		&i.RemainingQuantity,
		&i.BranchUuid,
		&i.MeasurementUnit,
		&i.OrganizationID,
	)
	return i, err
}

const listAllProductNames = `-- name: ListAllProductNames :many
select product_name
from products
where organization_id = $1
`

func (q *Queries) ListAllProductNames(ctx context.Context, organizationID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllProductNames, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_name string
		if err := rows.Scan(&product_name); err != nil {
			return nil, err
		}
		items = append(items, product_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersProductNames = `-- name: ListUsersProductNames :many
with user_branches as (select unnest(auth.branch_uuids) as branch_uuid
                       from auth
                       where user_email = $1)
select p.product_name
from products p
         join user_branches ub on p.branch_uuid = ub.branch_uuid
where p.organization_id = $2
`

type ListUsersProductNamesParams struct {
	UserEmail      string    `json:"user_email"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) ListUsersProductNames(ctx context.Context, arg ListUsersProductNamesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUsersProductNames, arg.UserEmail, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_name string
		if err := rows.Scan(&product_name); err != nil {
			return nil, err
		}
		items = append(items, product_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
