// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const conditionalUpdateAuth = `-- name: ConditionalUpdateAuth :one
UPDATE auth
SET password        = CASE
                       WHEN $1::INT = 1 THEN $2
                       ELSE password
END,
    keyset_data     = CASE
                       WHEN $3::INT = 1 THEN $4
                       ELSE keyset_data
END,
    encryption_key  = CASE
                       WHEN $5::INT = 1 THEN $6
                       ELSE encryption_key
END
WHERE user_profile_id = $7
RETURNING id, user_email, password, keyset_data, encryption_key, user_profile_id
`

type ConditionalUpdateAuthParams struct {
	Column1       int32          `json:"column_1"`
	Password      string         `json:"password"`
	Column3       int32          `json:"column_3"`
	KeysetData    sql.NullString `json:"keyset_data"`
	Column5       int32          `json:"column_5"`
	EncryptionKey sql.NullString `json:"encryption_key"`
	UserProfileID uuid.UUID      `json:"user_profile_id"`
}

func (q *Queries) ConditionalUpdateAuth(ctx context.Context, arg ConditionalUpdateAuthParams) (Auth, error) {
	row := q.db.QueryRowContext(ctx, conditionalUpdateAuth,
		arg.Column1,
		arg.Password,
		arg.Column3,
		arg.KeysetData,
		arg.Column5,
		arg.EncryptionKey,
		arg.UserProfileID,
	)
	var i Auth
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Password,
		&i.KeysetData,
		&i.EncryptionKey,
		&i.UserProfileID,
	)
	return i, err
}

const deleteUserKeySet = `-- name: DeleteUserKeySet :one
UPDATE auth
SET keyset_data = '',  encryption_key = ''
WHERE user_profile_id = $1
RETURNING id, user_email, password, keyset_data, encryption_key, user_profile_id
`

func (q *Queries) DeleteUserKeySet(ctx context.Context, userProfileID uuid.UUID) (Auth, error) {
	row := q.db.QueryRowContext(ctx, deleteUserKeySet, userProfileID)
	var i Auth
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Password,
		&i.KeysetData,
		&i.EncryptionKey,
		&i.UserProfileID,
	)
	return i, err
}

const getAllUserKeySet = `-- name: GetAllUserKeySet :many
SELECT user_profile_id, keyset_data, encryption_key
FROM auth
ORDER BY id DESC
`

type GetAllUserKeySetRow struct {
	UserProfileID uuid.UUID      `json:"user_profile_id"`
	KeysetData    sql.NullString `json:"keyset_data"`
	EncryptionKey sql.NullString `json:"encryption_key"`
}

func (q *Queries) GetAllUserKeySet(ctx context.Context) ([]GetAllUserKeySetRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserKeySet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserKeySetRow
	for rows.Next() {
		var i GetAllUserKeySetRow
		if err := rows.Scan(&i.UserProfileID, &i.KeysetData, &i.EncryptionKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, name
FROM organization
WHERE name = $1
`

func (q *Queries) GetOrganization(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganization, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUserAuth = `-- name: GetUserAuth :one
SELECT user_email, password, user_profile_id
FROM auth
WHERE user_email = $1
`

type GetUserAuthRow struct {
	UserEmail     string    `json:"user_email"`
	Password      string    `json:"password"`
	UserProfileID uuid.UUID `json:"user_profile_id"`
}

func (q *Queries) GetUserAuth(ctx context.Context, userEmail string) (GetUserAuthRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuth, userEmail)
	var i GetUserAuthRow
	err := row.Scan(&i.UserEmail, &i.Password, &i.UserProfileID)
	return i, err
}

const getUserKeySet = `-- name: GetUserKeySet :one
SELECT user_profile_id, keyset_data, encryption_key
FROM auth
WHERE user_profile_id = $1
`

type GetUserKeySetRow struct {
	UserProfileID uuid.UUID      `json:"user_profile_id"`
	KeysetData    sql.NullString `json:"keyset_data"`
	EncryptionKey sql.NullString `json:"encryption_key"`
}

func (q *Queries) GetUserKeySet(ctx context.Context, userProfileID uuid.UUID) (GetUserKeySetRow, error) {
	row := q.db.QueryRowContext(ctx, getUserKeySet, userProfileID)
	var i GetUserKeySetRow
	err := row.Scan(&i.UserProfileID, &i.KeysetData, &i.EncryptionKey)
	return i, err
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT up.full_name, up.user_role, a.user_email, a.user_profile_id
FROM user_profile up
         INNER JOIN auth a ON up.id = a.user_profile_id
WHERE a.user_email = $1
`

type GetUserProfileRow struct {
	FullName      string         `json:"full_name"`
	UserRole      sql.NullString `json:"user_role"`
	UserEmail     string         `json:"user_email"`
	UserProfileID uuid.UUID      `json:"user_profile_id"`
}

func (q *Queries) GetUserProfile(ctx context.Context, userEmail string) (GetUserProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getUserProfile, userEmail)
	var i GetUserProfileRow
	err := row.Scan(
		&i.FullName,
		&i.UserRole,
		&i.UserEmail,
		&i.UserProfileID,
	)
	return i, err
}

const insertOrganization = `-- name: InsertOrganization :one
INSERT INTO organization (name)
VALUES ($1)
    RETURNING id, name
`

func (q *Queries) InsertOrganization(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, insertOrganization, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const insertUserProfile = `-- name: InsertUserProfile :one
WITH user_profile_insert AS (
INSERT INTO user_profile (full_name, address, user_role)
VALUES ($1, $2, $3)
    RETURNING id
)
INSERT INTO auth (user_email, password, user_profile_id)
VALUES ($4, $5, (SELECT id FROM user_profile_insert))
    RETURNING id, user_email, password, keyset_data, encryption_key, user_profile_id
`

type InsertUserProfileParams struct {
	FullName  string         `json:"full_name"`
	Address   sql.NullString `json:"address"`
	UserRole  sql.NullString `json:"user_role"`
	UserEmail string         `json:"user_email"`
	Password  string         `json:"password"`
}

func (q *Queries) InsertUserProfile(ctx context.Context, arg InsertUserProfileParams) (Auth, error) {
	row := q.db.QueryRowContext(ctx, insertUserProfile,
		arg.FullName,
		arg.Address,
		arg.UserRole,
		arg.UserEmail,
		arg.Password,
	)
	var i Auth
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Password,
		&i.KeysetData,
		&i.EncryptionKey,
		&i.UserProfileID,
	)
	return i, err
}
