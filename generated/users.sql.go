// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"
)

const conditionalUpdateAuth = `-- name: ConditionalUpdateAuth :one
UPDATE auth
SET password        = CASE
                       WHEN $1::INT = 1 THEN $2
                       ELSE password
END,
    keyset_data     = CASE
                       WHEN $3::INT = 1 THEN $4
                       ELSE keyset_data
END,
    encryption_key  = CASE
                       WHEN $5::INT = 1 THEN $6
                       ELSE encryption_key
END
WHERE user_email = $7
RETURNING id, user_email, password, keyset_data, encryption_key, user_profile_id
`

type ConditionalUpdateAuthParams struct {
	Column1       int32          `json:"column_1"`
	Password      string         `json:"password"`
	Column3       int32          `json:"column_3"`
	KeysetData    sql.NullString `json:"keyset_data"`
	Column5       int32          `json:"column_5"`
	EncryptionKey sql.NullString `json:"encryption_key"`
	UserEmail     string         `json:"user_email"`
}

func (q *Queries) ConditionalUpdateAuth(ctx context.Context, arg ConditionalUpdateAuthParams) (Auth, error) {
	row := q.db.QueryRowContext(ctx, conditionalUpdateAuth,
		arg.Column1,
		arg.Password,
		arg.Column3,
		arg.KeysetData,
		arg.Column5,
		arg.EncryptionKey,
		arg.UserEmail,
	)
	var i Auth
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Password,
		&i.KeysetData,
		&i.EncryptionKey,
		&i.UserProfileID,
	)
	return i, err
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, name
FROM organization
WHERE name = $1
`

func (q *Queries) GetOrganization(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganization, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUserAuth = `-- name: GetUserAuth :one
SELECT user_email, password
FROM auth
WHERE user_email = $1
`

type GetUserAuthRow struct {
	UserEmail string `json:"user_email"`
	Password  string `json:"password"`
}

func (q *Queries) GetUserAuth(ctx context.Context, userEmail string) (GetUserAuthRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuth, userEmail)
	var i GetUserAuthRow
	err := row.Scan(&i.UserEmail, &i.Password)
	return i, err
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT up.full_name, up.user_role, a.user_email
FROM user_profile up
INNER JOIN auth a USING (id)
WHERE a.user_email = $1
`

type GetUserProfileRow struct {
	FullName  string         `json:"full_name"`
	UserRole  sql.NullString `json:"user_role"`
	UserEmail string         `json:"user_email"`
}

func (q *Queries) GetUserProfile(ctx context.Context, userEmail string) (GetUserProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getUserProfile, userEmail)
	var i GetUserProfileRow
	err := row.Scan(&i.FullName, &i.UserRole, &i.UserEmail)
	return i, err
}

const insertOrganization = `-- name: InsertOrganization :one
INSERT INTO organization (name)
VALUES ($1)
    RETURNING id, name
`

func (q *Queries) InsertOrganization(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, insertOrganization, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const insertUserProfile = `-- name: InsertUserProfile :one
WITH user_profile_insert AS (
INSERT INTO user_profile (full_name, address, user_role)
VALUES ($1, $2, $3)
    RETURNING id
)
INSERT INTO auth (user_email, password, user_profile_id)
VALUES ($4, $5, (SELECT id FROM user_profile_insert))
    RETURNING id, user_email, password, keyset_data, encryption_key, user_profile_id
`

type InsertUserProfileParams struct {
	FullName  string         `json:"full_name"`
	Address   sql.NullString `json:"address"`
	UserRole  sql.NullString `json:"user_role"`
	UserEmail string         `json:"user_email"`
	Password  string         `json:"password"`
}

func (q *Queries) InsertUserProfile(ctx context.Context, arg InsertUserProfileParams) (Auth, error) {
	row := q.db.QueryRowContext(ctx, insertUserProfile,
		arg.FullName,
		arg.Address,
		arg.UserRole,
		arg.UserEmail,
		arg.Password,
	)
	var i Auth
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.Password,
		&i.KeysetData,
		&i.EncryptionKey,
		&i.UserProfileID,
	)
	return i, err
}
